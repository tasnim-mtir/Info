import * as i0 from '@angular/core';
import { Injectable, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, EventEmitter, Output, NgModule } from '@angular/core';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import { Subject } from 'rxjs/internal/Subject';

var PieceRotation;
(function (PieceRotation) {
    PieceRotation[PieceRotation["DEG_0"] = 0] = "DEG_0";
    PieceRotation[PieceRotation["DEG_90"] = 1] = "DEG_90";
    PieceRotation[PieceRotation["DEG_180"] = 2] = "DEG_180";
    PieceRotation[PieceRotation["DEG_270"] = 3] = "DEG_270";
})(PieceRotation || (PieceRotation = {}));
var PieceTypes;
(function (PieceTypes) {
    PieceTypes[PieceTypes["Dot"] = 1] = "Dot";
    PieceTypes[PieceTypes["Box"] = 2] = "Box";
    PieceTypes[PieceTypes["Line"] = 3] = "Line";
    PieceTypes[PieceTypes["T"] = 4] = "T";
    PieceTypes[PieceTypes["L"] = 5] = "L";
    PieceTypes[PieceTypes["Lr"] = 6] = "Lr";
    PieceTypes[PieceTypes["Z"] = 7] = "Z";
    PieceTypes[PieceTypes["S"] = 8] = "S";
})(PieceTypes || (PieceTypes = {}));
// picked from https://www.romanzolotarev.com/pico-8-color-palette/
var PieceColors;
(function (PieceColors) {
    PieceColors["Box"] = "color-box";
    PieceColors["Dot"] = "color-dot";
    PieceColors["Line"] = "color-line";
    PieceColors["T"] = "color-t";
    PieceColors["L"] = "color-l";
    PieceColors["Lr"] = "color-lr";
    PieceColors["Z"] = "color-z";
    PieceColors["S"] = "color-s";
})(PieceColors || (PieceColors = {}));
class Piece {
    constructor(x, y, gridSize, maps) {
        this.color = 'red';
        this.rotation = PieceRotation.DEG_0;
        this.map = [
            [], []
        ];
        this._lastConfig = null;
        this._gridSize = gridSize;
        this.x = x;
        this.y = y;
        this._maps = maps;
        this.map = this._maps[this.rotation];
    }
    get positionsOnGrid() {
        const acc = [];
        for (let row = 0; row < 4; row++) {
            for (let col = 0; col < 4; col++) {
                if (this.map[row][col]) {
                    const pos = (this.y + row) * this._gridSize.width + this.x + col;
                    if (pos > 0) {
                        acc.push(pos);
                    }
                }
            }
        }
        return acc;
    }
    store() {
        this._lastConfig = {
            x: this.x,
            y: this.y,
            rotation: this.rotation,
            map: this.map
        };
    }
    clearStore() {
        this._lastConfig = null;
    }
    revert() {
        if (this._lastConfig) {
            for (const x in this._lastConfig) {
                if (this._lastConfig.hasOwnProperty(x)) {
                    // @ts-ignore
                    this[x] = this._lastConfig[x];
                }
            }
            this._lastConfig = null;
        }
    }
    rotate() {
        const keys = Object.keys(this._maps);
        let idx = keys.indexOf(this.rotation.toString());
        if (idx >= keys.length - 1) {
            this.rotation = keys[0];
        }
        else {
            this.rotation = keys[++idx];
        }
        this.map = this._maps[this.rotation];
    }
    moveDown() {
        this.y++;
    }
    moveRight() {
        this.x++;
    }
    moveLeft() {
        this.x--;
    }
    get bottomRow() {
        return this.y + 3;
    }
    get rightCol() {
        let col = 3;
        while (col >= 0) {
            for (let row = 0; row <= 3; row++) {
                if (this.map[row][col]) {
                    return this.x + col;
                }
            }
            col--;
        }
        return 0;
    }
    get leftCol() {
        return this.x;
    }
}

const MAPS$7 = [];
MAPS$7[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Box, undefined, undefined, undefined],
];
class Dot extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$7);
        this.color = PieceColors['Dot'];
    }
}

const MAPS$6 = [];
MAPS$6[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Box, PieceTypes.Box, undefined, undefined],
    [PieceTypes.Box, PieceTypes.Box, undefined, undefined],
];
class Box extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$6);
        this.color = PieceColors['Box'];
    }
}

const MAPS$5 = [];
MAPS$5[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Line, PieceTypes.Line, PieceTypes.Line, PieceTypes.Line],
];
MAPS$5[PieceRotation.DEG_90] = [
    [PieceTypes.Line, undefined, undefined, undefined],
    [PieceTypes.Line, undefined, undefined, undefined],
    [PieceTypes.Line, undefined, undefined, undefined],
    [PieceTypes.Line, undefined, undefined, undefined],
];
class Line extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$5);
        this.color = PieceColors['Line'];
    }
}

const MAPS$4 = [];
MAPS$4[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [undefined, PieceTypes.T, undefined, undefined],
    [PieceTypes.T, PieceTypes.T, PieceTypes.T, undefined],
];
MAPS$4[PieceRotation.DEG_90] = [
    [undefined, undefined, undefined, undefined],
    [PieceTypes.T, undefined, undefined, undefined],
    [PieceTypes.T, PieceTypes.T, undefined, undefined],
    [PieceTypes.T, undefined, undefined, undefined],
];
MAPS$4[PieceRotation.DEG_180] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.T, PieceTypes.T, PieceTypes.T, undefined],
    [undefined, PieceTypes.T, undefined, undefined],
];
MAPS$4[PieceRotation.DEG_270] = [
    [undefined, undefined, undefined, undefined],
    [undefined, PieceTypes.T, undefined, undefined],
    [PieceTypes.T, PieceTypes.T, undefined, undefined],
    [undefined, PieceTypes.T, undefined, undefined],
];
class T extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$4);
        this.color = PieceColors['T'];
    }
}

const MAPS$3 = [];
MAPS$3[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [undefined, PieceTypes.Z, undefined, undefined],
    [PieceTypes.Z, PieceTypes.Z, undefined, undefined],
    [PieceTypes.Z, undefined, undefined, undefined],
];
MAPS$3[PieceRotation.DEG_90] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Z, PieceTypes.Z, undefined, undefined],
    [undefined, PieceTypes.Z, PieceTypes.Z, undefined],
];
class Z extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$3);
        this.color = PieceColors['Z'];
    }
}

const MAPS$2 = [];
MAPS$2[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [PieceTypes.S, undefined, undefined, undefined],
    [PieceTypes.S, PieceTypes.S, undefined, undefined],
    [undefined, PieceTypes.S, undefined, undefined],
];
MAPS$2[PieceRotation.DEG_90] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [undefined, PieceTypes.S, PieceTypes.S, undefined],
    [PieceTypes.S, PieceTypes.S, undefined, undefined],
];
class S extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$2);
        this.color = PieceColors['S'];
    }
}

const MAPS$1 = [];
MAPS$1[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [PieceTypes.L, undefined, undefined, undefined],
    [PieceTypes.L, undefined, undefined, undefined],
    [PieceTypes.L, PieceTypes.L, undefined, undefined],
];
MAPS$1[PieceRotation.DEG_90] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.L, PieceTypes.L, PieceTypes.L, undefined],
    [PieceTypes.L, undefined, undefined, undefined],
];
MAPS$1[PieceRotation.DEG_180] = [
    [undefined, undefined, undefined, undefined],
    [PieceTypes.L, PieceTypes.L, undefined, undefined],
    [undefined, PieceTypes.L, undefined, undefined],
    [undefined, PieceTypes.L, undefined, undefined],
];
MAPS$1[PieceRotation.DEG_270] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, PieceTypes.L, undefined],
    [PieceTypes.L, PieceTypes.L, PieceTypes.L, undefined],
];
class L extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS$1);
        this.color = PieceColors['L'];
    }
}

const MAPS = [];
MAPS[PieceRotation.DEG_0] = [
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Lr, PieceTypes.Lr, undefined, undefined],
    [undefined, PieceTypes.Lr, undefined, undefined],
    [undefined, PieceTypes.Lr, undefined, undefined],
];
MAPS[PieceRotation.DEG_90] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, PieceTypes.Lr, undefined],
    [PieceTypes.Lr, PieceTypes.Lr, PieceTypes.Lr, undefined],
];
MAPS[PieceRotation.DEG_180] = [
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Lr, undefined, undefined, undefined],
    [PieceTypes.Lr, undefined, undefined, undefined],
    [PieceTypes.Lr, PieceTypes.Lr, undefined, undefined],
];
MAPS[PieceRotation.DEG_270] = [
    [undefined, undefined, undefined, undefined],
    [undefined, undefined, undefined, undefined],
    [PieceTypes.Lr, PieceTypes.Lr, PieceTypes.Lr, undefined],
    [PieceTypes.Lr, undefined, undefined, undefined],
];
class Lr extends Piece {
    constructor(x, y, gridSize) {
        super(x, y, gridSize, MAPS);
        this.color = PieceColors['Lr'];
    }
}

class PiecesFactory {
    constructor(_gridSize) {
        this._gridSize = _gridSize;
        this._available = [];
        // @ts-ignore
        this._available.push(Dot);
        // @ts-ignore
        this._available.push(Box);
        // @ts-ignore
        this._available.push(Line);
        // @ts-ignore
        this._available.push(T);
        // @ts-ignore
        this._available.push(Z);
        // @ts-ignore
        this._available.push(S);
        // @ts-ignore
        this._available.push(L);
        // @ts-ignore
        this._available.push(Lr);
    }
    getRandomPiecePiece(x, y) {
        const idx = Math.floor(Math.random() * (this._available.length));
        // @ts-ignore
        return new this._available[idx](x, y, this._gridSize);
        // return new this._available[2](x, y, this._gridSize);
    }
}

const SPAWN_POSITION_X = 4;
const SPAWN_POSITION_Y = -4;
class Tile {
    constructor() {
        this.solid = false;
        this.color = null;
    }
}
class GameManagerService {
    constructor() {
        this.settings = {
            tileSize: null
        };
        this._gridSize = { width: 0, height: 0 };
        this._locked = true;
        this._lineCleared = new Subject();
        this._gameOver = new Subject();
        this._keepMovingDown = false;
        this.lineCleared$ = this._lineCleared.asObservable();
        this.gameOver$ = this._gameOver.asObservable();
    }
    get elementsInRow() {
        return this._gridSize.width;
    }
    initialize(width, height, gameSpeed, tileSize) {
        this._gridSize.width = width;
        this._gridSize.height = height;
        this._gameSpeed = gameSpeed;
        this._piecesFactory = new PiecesFactory(this._gridSize);
        if (tileSize) {
            this.settings.tileSize = tileSize;
        }
        this._initializeEmptyBoard();
        this._spawnNewPiece();
        this._drawPiece();
    }
    start() {
        clearInterval(this._gameInterval);
        this._gameInterval = setInterval(() => {
            this._update();
        }, this._gameSpeed);
        this._locked = false;
    }
    stop() {
        this._locked = true;
        clearInterval(this._gameInterval);
    }
    reset() {
        const emptyTile = new Tile();
        for (let pos = 0; pos < this.grid.length; pos++) {
            if (this.grid[pos].color || this.grid[pos].solid) {
                this.__changeCell(pos, emptyTile);
            }
        }
        this._spawnNewPiece();
        this._drawPiece();
    }
    moveLeft() {
        if (this._locked) {
            return;
        }
        this._clearPiece();
        this._piece.store();
        this._piece.moveLeft();
        if (this._collidesLeft()) {
            this._piece.revert();
        }
        this._drawPiece();
    }
    moveRight() {
        if (this._locked) {
            return;
        }
        this._clearPiece();
        this._piece.store();
        this._piece.moveRight();
        if (this._collidesRight()) {
            this._piece.revert();
        }
        this._drawPiece();
    }
    drop() {
        if (this._locked) {
            return;
        }
        this._keepMovingDown = true;
        while (!this._collidesBottom() && this._keepMovingDown) {
            this._update();
        }
    }
    rotate() {
        if (this._locked) {
            return;
        }
        this._clearPiece();
        this._piece.store();
        this._piece.rotate();
        while (this._collidesRight()) {
            this._piece.moveLeft();
            if (this._collidesLeft()) {
                this._piece.revert();
                break;
            }
        }
        this._drawPiece();
    }
    moveDown() {
        this._update();
    }
    _clearFullLines() {
        for (let row = this._gridSize.height - 1; row >= 0; row--) {
            let isFull = true;
            for (let col = 0; col < this._gridSize.width; col++) {
                const pos = row * this._gridSize.width + col;
                if (this.grid[pos].solid === false) {
                    isFull = false;
                    break;
                }
            }
            if (isFull) {
                const emptyRow = Array.apply(null, Array(this._gridSize.width))
                    .map((idx) => new Tile());
                const topPortion = this.grid.slice(0, row * this._gridSize.width);
                this.grid.splice(0, ++row * this._gridSize.width, ...emptyRow.concat(topPortion));
                this._lineCleared.next();
            }
        }
    }
    _update() {
        if (this._locked) {
            return;
        }
        this._locked = true;
        this._piece.revert();
        this._clearPiece();
        this._piece.store();
        this._piece.moveDown();
        if (this._collidesBottom()) {
            this._keepMovingDown = false;
            this._piece.revert();
            this._markSolid();
            this._drawPiece();
            this._clearFullLines();
            this._spawnNewPiece();
            if (this._isGameOver()) {
                this._onGameOver();
                return;
            }
        }
        this._drawPiece();
        this._locked = false;
    }
    _isGameOver() {
        this._piece.store();
        this._piece.moveDown();
        if (this._collidesBottom()) {
            return true;
        }
        this._piece.revert();
        return false;
    }
    _onGameOver() {
        this.stop();
        this._gameOver.next();
    }
    _spawnNewPiece() {
        this._piece = this._piecesFactory.getRandomPiecePiece(SPAWN_POSITION_X, SPAWN_POSITION_Y);
    }
    _initializeEmptyBoard() {
        const cellsCount = this._gridSize.width * this._gridSize.height;
        this.grid = Array.apply(null, Array(cellsCount))
            .map((idx) => new Tile());
    }
    _clearPiece() {
        this._piece.positionsOnGrid
            .forEach((pos) => {
            this.__changeCell(pos, { color: undefined });
        });
    }
    _drawPiece() {
        this._piece.clearStore();
        this._piece.positionsOnGrid
            .forEach((pos) => {
            this.__changeCell(pos, { color: this._piece.color });
        });
    }
    _markSolid() {
        this._piece.positionsOnGrid.forEach((pos) => {
            this.__changeCell(pos, { solid: true });
        });
    }
    __changeCell(pos, data = {}) {
        this.grid[pos] = Object.assign({}, this.grid[pos], data);
    }
    _collidesBottom() {
        if (this._piece.bottomRow >= this._gridSize.height) {
            return true;
        }
        return this.__collides();
    }
    _collidesLeft() {
        if (this._piece.leftCol < 0) {
            return true;
        }
        return this.__collides();
    }
    _collidesRight() {
        if (this._piece.rightCol >= this._gridSize.width) {
            return true;
        }
        return this.__collides();
    }
    __collides() {
        return this._piece.positionsOnGrid
            .some((pos) => {
            if (pos > 0 && this.grid[pos] && this.grid[pos].solid) {
                return true;
            }
            return false;
        });
    }
}
GameManagerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: GameManagerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
GameManagerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: GameManagerService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: GameManagerService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return []; } });

class TileComponent {
    constructor(el, _renderer, _manager) {
        this.el = el;
        this._renderer = _renderer;
        this._manager = _manager;
        this.tileSize = null;
        if (this._manager.settings.tileSize) {
            this.tileSize = this._manager.settings.tileSize;
        }
    }
    ngOnInit() {
        if (this.data.color) {
            this._renderer.addClass(this.el.nativeElement, this.data.color);
        }
    }
}
TileComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TileComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: GameManagerService }], target: i0.ɵɵFactoryTarget.Component });
TileComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.2", type: TileComponent, selector: "tile", inputs: { data: "data" }, host: { properties: { "style.width": "tileSize", "style.height": "tileSize" } }, ngImport: i0, template: "", styles: ["tile{display:block;background:rgba(176,230,225,.35);width:25px;height:25px;float:left;border:1px solid #4e4645;margin:1px}tile.color-box{background:#FFCCAA}tile.color-dot{background:#FF77A8}tile.color-line{background:#83769C}tile.color-t{background:#29ADFF}tile.color-l{background:#00E436}tile.color-lr{background:#FFEC27}tile.color-z{background:#FFA300}tile.color-s{background:#C2C3C7}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TileComponent, decorators: [{
            type: Component,
            args: [{ selector: 'tile', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[style.width]': 'tileSize',
                        '[style.height]': 'tileSize'
                    }, template: "", styles: ["tile{display:block;background:rgba(176,230,225,.35);width:25px;height:25px;float:left;border:1px solid #4e4645;margin:1px}tile.color-box{background:#FFCCAA}tile.color-dot{background:#FF77A8}tile.color-line{background:#83769C}tile.color-t{background:#29ADFF}tile.color-l{background:#00E436}tile.color-lr{background:#FFEC27}tile.color-z{background:#FFA300}tile.color-s{background:#C2C3C7}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: GameManagerService }]; }, propDecorators: { data: [{
                type: Input
            }] } });

class BoardComponent {
    constructor(_manager, _elRef) {
        this._manager = _manager;
        this._elRef = _elRef;
    }
    ngAfterViewInit() {
        if (this._manager.settings.tileSize) {
            const bb = this.tile.el.nativeElement.getBoundingClientRect();
            const TILE_MARGIN = 1; //px
            const oneTileSpace = bb.width + 2 * TILE_MARGIN;
            const boardWidth = oneTileSpace * this._manager.elementsInRow;
            this._elRef.nativeElement.style['width'] = boardWidth + 'px';
        }
    }
}
BoardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: BoardComponent, deps: [{ token: GameManagerService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
BoardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.2", type: BoardComponent, selector: "board", inputs: { grid: "grid" }, viewQueries: [{ propertyName: "tile", first: true, predicate: TileComponent, descendants: true }], ngImport: i0, template: "<tile *ngFor=\"let tileData of grid\"\n    [data]=\"tileData\">\n</tile>\n", styles: [":host{width:290px;display:block}\n"], components: [{ type: TileComponent, selector: "tile", inputs: ["data"] }], directives: [{ type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: BoardComponent, decorators: [{
            type: Component,
            args: [{ selector: 'board', template: "<tile *ngFor=\"let tileData of grid\"\n    [data]=\"tileData\">\n</tile>\n", styles: [":host{width:290px;display:block}\n"] }]
        }], ctorParameters: function () { return [{ type: GameManagerService }, { type: i0.ElementRef }]; }, propDecorators: { grid: [{
                type: Input
            }], tile: [{
                type: ViewChild,
                args: [TileComponent]
            }] } });

const GAME_SPEED = 500;
const MOVE_DOWN_SPEED = 0.2; // fraction of initial game speed
var GameState;
(function (GameState) {
    GameState[GameState["Paused"] = 0] = "Paused";
    GameState[GameState["Started"] = 1] = "Started";
    GameState[GameState["Over"] = 2] = "Over";
})(GameState || (GameState = {}));
class TetrisCoreComponent {
    constructor(_manager) {
        this._manager = _manager;
        this.initialSpeed = GAME_SPEED;
        this.rotate = false;
        this.moveLeft = false;
        this.moveRight = false;
        this.moveDown = false;
        this.drop = false;
        this.start = false;
        this.stop = false;
        this.reset = false;
        this.lineCleared = new EventEmitter();
        this.gameOver = new EventEmitter();
        this.state = GameState.Paused;
        this.gridWidth = 10;
        this.gridHeight = 20;
        this._moveDownSpeed = GAME_SPEED * MOVE_DOWN_SPEED;
        this._manager.lineCleared$.subscribe(() => this._onLineCleared());
        this._manager.gameOver$.subscribe(() => this._onGameOver());
    }
    ngOnInit() {
        this._moveDownSpeed = this.initialSpeed * MOVE_DOWN_SPEED;
        this._manager.initialize(this.gridWidth, this.gridHeight, this.initialSpeed, this.tileSize);
        this.grid = this._manager.grid;
        setInterval(() => {
            if (this.moveDown) {
                this._manager.moveDown();
            }
        }, this._moveDownSpeed);
    }
    ngOnChanges(changes) {
        if (this._keyPressed(changes['moveLeft'])) {
            this._manager.moveLeft();
        }
        else if (this._keyPressed(changes['moveRight'])) {
            this._manager.moveRight();
        }
        else if (this._keyPressed(changes['drop'])) {
            this._manager.drop();
        }
        if (this._keyPressed(changes['rotate'])) {
            this._manager.rotate();
        }
        if (this._keyPressed(changes['start'])) {
            this._manager.start();
        }
        if (this._keyPressed(changes['stop'])) {
            this._manager.stop();
        }
        if (this._keyPressed(changes['reset'])) {
            this._manager.reset();
        }
    }
    actionLeft() { this._manager.moveLeft(); }
    actionRight() { this._manager.moveRight(); }
    actionRotate() { this._manager.rotate(); }
    actionDown() { this._manager.moveDown(); }
    actionDrop() { this._manager.drop(); }
    actionReset() { this._manager.reset(); }
    actionStart() {
        this._manager.start();
        this.state = GameState.Started;
    }
    actionStop() {
        this._manager.stop();
        this.state = GameState.Paused;
    }
    _keyPressed(key) {
        return key && key.currentValue && !key.previousValue;
    }
    _onLineCleared() {
        this.lineCleared.emit();
    }
    _onGameOver() {
        this.state = GameState.Over;
        this.gameOver.emit();
    }
}
TetrisCoreComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TetrisCoreComponent, deps: [{ token: GameManagerService }], target: i0.ɵɵFactoryTarget.Component });
TetrisCoreComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.0.2", type: TetrisCoreComponent, selector: "tetris-core", inputs: { tileSize: "tileSize", initialSpeed: "initialSpeed", rotate: "rotate", moveLeft: "moveLeft", moveRight: "moveRight", moveDown: "moveDown", drop: "drop", start: "start", stop: "stop", reset: "reset" }, outputs: { lineCleared: "lineCleared", gameOver: "gameOver" }, usesOnChanges: true, ngImport: i0, template: "<board\n    [grid]=\"grid\"></board>\n", components: [{ type: BoardComponent, selector: "board", inputs: ["grid"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TetrisCoreComponent, decorators: [{
            type: Component,
            args: [{ selector: 'tetris-core', template: "<board\n    [grid]=\"grid\"></board>\n" }]
        }], ctorParameters: function () { return [{ type: GameManagerService }]; }, propDecorators: { tileSize: [{
                type: Input
            }], initialSpeed: [{
                type: Input
            }], rotate: [{
                type: Input
            }], moveLeft: [{
                type: Input
            }], moveRight: [{
                type: Input
            }], moveDown: [{
                type: Input
            }], drop: [{
                type: Input
            }], start: [{
                type: Input
            }], stop: [{
                type: Input
            }], reset: [{
                type: Input
            }], lineCleared: [{
                type: Output
            }], gameOver: [{
                type: Output
            }] } });

class TetrisCoreModule {
}
TetrisCoreModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TetrisCoreModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
TetrisCoreModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TetrisCoreModule, declarations: [TetrisCoreComponent,
        BoardComponent,
        TileComponent], imports: [CommonModule], exports: [TetrisCoreComponent] });
TetrisCoreModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TetrisCoreModule, providers: [
        GameManagerService
    ], imports: [[
            CommonModule
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: TetrisCoreModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        TetrisCoreComponent,
                        BoardComponent,
                        TileComponent
                    ],
                    providers: [
                        GameManagerService
                    ],
                    exports: [TetrisCoreComponent]
                }]
        }] });

/*
 * Public API Surface of ngx-tetris
 */

/**
 * Generated bundle index. Do not edit.
 */

export { GameState, TetrisCoreComponent, TetrisCoreModule };
