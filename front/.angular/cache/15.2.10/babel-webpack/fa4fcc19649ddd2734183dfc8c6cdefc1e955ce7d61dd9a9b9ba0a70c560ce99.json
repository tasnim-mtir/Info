{"ast":null,"code":"import { PiecesFactory } from '../classes/PiecesFactory';\nimport { Subject } from 'rxjs/internal/Subject';\nimport * as i0 from \"@angular/core\";\nconst SPAWN_POSITION_X = 4;\nconst SPAWN_POSITION_Y = -4;\nexport class Tile {\n  constructor() {\n    this.solid = false;\n    this.color = null;\n  }\n}\nexport class GameManagerService {\n  constructor() {\n    this.score = 0;\n    this.settings = {\n      tileSize: null\n    };\n    this._gridSize = {\n      width: 0,\n      height: 0\n    };\n    this._locked = true;\n    this._lineCleared = new Subject();\n    this._gameOver = new Subject();\n    this._keepMovingDown = false;\n    this.lineCleared$ = this._lineCleared.asObservable();\n    this.gameOver$ = this._gameOver.asObservable();\n  }\n  resume() {\n    throw new Error('Method not implemented.');\n  }\n  get elementsInRow() {\n    return this._gridSize.width;\n  }\n  initialize(width, height, gameSpeed, tileSize) {\n    this._initialGameSpeed = gameSpeed;\n    this._gridSize.width = width;\n    this._gridSize.height = height;\n    this._gameSpeed = gameSpeed;\n    this._piecesFactory = new PiecesFactory(this._gridSize);\n    if (tileSize) {\n      this.settings.tileSize = tileSize;\n    }\n    this._initializeEmptyBoard();\n    this._spawnNewPiece();\n    this._drawPiece();\n  }\n  start() {\n    clearInterval(this._gameInterval);\n    this._gameInterval = setInterval(() => {\n      this._update();\n    }, this._gameSpeed);\n    this._locked = false;\n  }\n  stop() {\n    this._locked = true;\n    clearInterval(this._gameInterval);\n  }\n  reset() {\n    const emptyTile = new Tile();\n    for (let pos = 0; pos < this.grid.length; pos++) {\n      if (this.grid[pos].color || this.grid[pos].solid) {\n        this.__changeCell(pos, emptyTile);\n      }\n    }\n    this._spawnNewPiece();\n    this._drawPiece();\n    this.updateGameSpeed(this._initialGameSpeed);\n  }\n  moveLeft() {\n    if (this._locked) {\n      return;\n    }\n    this._clearPiece();\n    this._piece.store();\n    this._piece.moveLeft();\n    if (this._collidesLeft()) {\n      this._piece.revert();\n    }\n    this._drawPiece();\n  }\n  moveRight() {\n    if (this._locked) {\n      return;\n    }\n    this._clearPiece();\n    this._piece.store();\n    this._piece.moveRight();\n    if (this._collidesRight()) {\n      this._piece.revert();\n    }\n    this._drawPiece();\n  }\n  drop() {\n    if (this._locked) {\n      return;\n    }\n    this._keepMovingDown = true;\n    while (!this._collidesBottom() && this._keepMovingDown) {\n      this._update();\n    }\n  }\n  rotate() {\n    if (this._locked) {\n      return;\n    }\n    this._clearPiece();\n    this._piece.store();\n    this._piece.rotate();\n    while (this._collidesRight()) {\n      this._piece.moveLeft();\n      if (this._collidesLeft()) {\n        this._piece.revert();\n        break;\n      }\n    }\n    this._drawPiece();\n  }\n  moveDown() {\n    this._update();\n  }\n  _clearFullLines() {\n    let linesCleared = 0;\n    for (let row = this._gridSize.height - 1; row >= 0; row--) {\n      let isFull = true;\n      for (let col = 0; col < this._gridSize.width; col++) {\n        const pos = row * this._gridSize.width + col;\n        if (this.grid[pos].solid === false) {\n          isFull = false;\n          break;\n        }\n      }\n      if (isFull) {\n        const emptyRow = Array.apply(null, Array(this._gridSize.width)).map(idx => new Tile());\n        const topPortion = this.grid.slice(0, row * this._gridSize.width);\n        this.grid.splice(0, ++row * this._gridSize.width, ...emptyRow.concat(topPortion));\n        this._lineCleared.next();\n        linesCleared++;\n      }\n    }\n    if (linesCleared > 0) {\n      const speedIncrement = 15;\n      const newGameSpeed = this._gameSpeed - linesCleared * speedIncrement;\n      this.updateGameSpeed(newGameSpeed);\n      const scoreIncrement = 20;\n      this.score += linesCleared * scoreIncrement;\n    }\n  }\n  _update() {\n    if (this._locked) {\n      return;\n    }\n    this._locked = true;\n    this._piece.revert();\n    this._clearPiece();\n    this._piece.store();\n    this._piece.moveDown();\n    if (this._collidesBottom()) {\n      this._keepMovingDown = false;\n      this._piece.revert();\n      this._markSolid();\n      this._drawPiece();\n      this._clearFullLines();\n      this._spawnNewPiece();\n      if (this._isGameOver()) {\n        this._onGameOver();\n        return;\n      }\n    }\n    this._drawPiece();\n    this._locked = false;\n  }\n  _isGameOver() {\n    this._piece.store();\n    this._piece.moveDown();\n    if (this._collidesBottom()) {\n      return true;\n    }\n    this._piece.revert();\n    return false;\n  }\n  _onGameOver() {\n    this.stop();\n    this._gameOver.next();\n  }\n  _spawnNewPiece() {\n    this._piece = this._piecesFactory.getRandomPiecePiece(SPAWN_POSITION_X, SPAWN_POSITION_Y);\n  }\n  _initializeEmptyBoard() {\n    const cellsCount = this._gridSize.width * this._gridSize.height;\n    this.grid = Array.apply(null, Array(cellsCount)).map(idx => new Tile());\n  }\n  _clearPiece() {\n    this._piece.positionsOnGrid.forEach(pos => {\n      this.__changeCell(pos, {\n        color: undefined\n      });\n    });\n  }\n  _drawPiece() {\n    this._piece.clearStore();\n    this._piece.positionsOnGrid.forEach(pos => {\n      this.__changeCell(pos, {\n        color: this._piece.color\n      });\n    });\n  }\n  _markSolid() {\n    this._piece.positionsOnGrid.forEach(pos => {\n      this.__changeCell(pos, {\n        solid: true\n      });\n    });\n  }\n  __changeCell(pos, data = {}) {\n    this.grid[pos] = Object.assign({}, this.grid[pos], data);\n  }\n  _collidesBottom() {\n    if (this._piece.bottomRow >= this._gridSize.height) {\n      return true;\n    }\n    return this.__collides();\n  }\n  _collidesLeft() {\n    if (this._piece.leftCol < 0) {\n      return true;\n    }\n    return this.__collides();\n  }\n  _collidesRight() {\n    if (this._piece.rightCol >= this._gridSize.width) {\n      return true;\n    }\n    return this.__collides();\n  }\n  __collides() {\n    return this._piece.positionsOnGrid.some(pos => {\n      if (pos > 0 && this.grid[pos] && this.grid[pos].solid) {\n        return true;\n      }\n      return false;\n    });\n  }\n  updateGameSpeed(speed) {\n    this._gameSpeed = speed;\n    this.restartGameInterval();\n  }\n  restartGameInterval() {\n    clearInterval(this._gameInterval);\n    this._gameInterval = setInterval(() => {\n      if (this.moveDown) {\n        this.moveDown();\n      }\n    }, this._gameSpeed);\n  }\n  static #_ = this.ɵfac = function GameManagerService_Factory(t) {\n    return new (t || GameManagerService)();\n  };\n  static #_2 = this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: GameManagerService,\n    factory: GameManagerService.ɵfac\n  });\n}","map":{"version":3,"mappings":"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","names":["PiecesFactory","Subject","SPAWN_POSITION_X","SPAWN_POSITION_Y","Tile","constructor","GameManagerService","tileSize","width","height","lineCleared$","_lineCleared","asObservable","gameOver$","_gameOver","resume","Error","elementsInRow","_gridSize","initialize","gameSpeed","_initialGameSpeed","_gameSpeed","_piecesFactory","settings","_initializeEmptyBoard","_spawnNewPiece","_drawPiece","start","clearInterval","_gameInterval","setInterval","_update","_locked","stop","reset","emptyTile","pos","grid","length","color","solid","__changeCell","updateGameSpeed","moveLeft","_clearPiece","_piece","store","_collidesLeft","revert","moveRight","_collidesRight","drop","_keepMovingDown","_collidesBottom","rotate","moveDown","_clearFullLines","linesCleared","row","isFull","col","emptyRow","Array","apply","map","idx","topPortion","slice","splice","concat","next","speedIncrement","newGameSpeed","scoreIncrement","score","_markSolid","_isGameOver","_onGameOver","getRandomPiecePiece","cellsCount","positionsOnGrid","forEach","undefined","clearStore","data","Object","assign","bottomRow","__collides","leftCol","rightCol","some","speed","restartGameInterval","factory"],"sourceRoot":"","sources":["C:\\Users\\Eyakr\\Info\\front\\ngx-tetris\\src\\lib\\services\\game-manager.service.ts"],"sourcesContent":["import {Injectable} from '@angular/core';\r\nimport {Piece} from '../classes/Piece';\r\nimport {PiecesFactory} from '../classes/PiecesFactory';\r\nimport {Observable} from 'rxjs/internal/Observable';\r\nimport {Subject} from 'rxjs/internal/Subject';\r\n\r\nconst SPAWN_POSITION_X = 4;\r\nconst SPAWN_POSITION_Y = -4;\r\n\r\nexport class Tile {\r\n    solid = false;\r\n    color = null;\r\n}\r\n\r\n@Injectable()\r\nexport class GameManagerService {\r\n    resume() {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n\r\n    public score: number = 0;\r\n\r\n    public settings = {\r\n        tileSize: null\r\n    };\r\n\r\n    public get elementsInRow() {\r\n        return this._gridSize.width;\r\n    }\r\n\r\n\r\n    public grid!: Array<Tile>;\r\n\r\n    public lineCleared$: Observable<any>;\r\n    public gameOver$: Observable<any>;\r\n\r\n    private _gridSize: {\r\n        width: number,\r\n        height: number\r\n    } = { width: 0, height: 0 };\r\n    private _initialGameSpeed!: number; \r\n\r\n    private _piece!: Piece;\r\n    private _piecesFactory!: PiecesFactory;\r\n\r\n    private _locked = true;\r\n    private _gameSpeed!: number;\r\n    private _gameInterval: NodeJS.Timeout | undefined;\r\n\r\n    private _lineCleared = new Subject<void>();\r\n    private _gameOver = new Subject<void>();\r\n\r\n    private _keepMovingDown = false;\r\n\r\n    constructor() {\r\n        this.lineCleared$ = this._lineCleared.asObservable();\r\n        this.gameOver$ = this._gameOver.asObservable();\r\n    }\r\n\r\n    public initialize(width: number, height: number, gameSpeed: number, tileSize?: any) {\r\n        this._initialGameSpeed = gameSpeed; \r\n        this._gridSize.width = width;\r\n        this._gridSize.height = height;\r\n        this._gameSpeed = gameSpeed;\r\n        this._piecesFactory = new PiecesFactory(this._gridSize);\r\n\r\n        if (tileSize) {\r\n            this.settings.tileSize = tileSize;\r\n        }\r\n\r\n        this._initializeEmptyBoard();\r\n\r\n        this._spawnNewPiece();\r\n        this._drawPiece();\r\n    }\r\n\r\n    public start() {\r\n        clearInterval(this._gameInterval);\r\n        this._gameInterval = setInterval(() => {\r\n            this._update();\r\n        }, this._gameSpeed);\r\n        this._locked = false;\r\n    }\r\n\r\n    public stop() {\r\n        this._locked = true;\r\n        clearInterval(this._gameInterval);\r\n    }\r\n\r\n\r\n  public reset() {\r\n    const emptyTile = new Tile();\r\n    for (let pos = 0; pos < this.grid.length; pos++) {\r\n      if (this.grid[pos].color || this.grid[pos].solid) {\r\n        this.__changeCell(pos, emptyTile);\r\n      }\r\n    }\r\n\r\n    this._spawnNewPiece();\r\n    this._drawPiece();\r\n\r\n    this.updateGameSpeed(this._initialGameSpeed); \r\n  }\r\n\r\n    public moveLeft() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.moveLeft();\r\n        if (this._collidesLeft()) {\r\n            this._piece.revert();\r\n        }\r\n\r\n        this._drawPiece();\r\n    }\r\n\r\n    public moveRight() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.moveRight();\r\n        if (this._collidesRight()) {\r\n            this._piece.revert();\r\n        }\r\n\r\n        this._drawPiece();\r\n    }\r\n\r\n    public drop() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._keepMovingDown = true;\r\n        while (!this._collidesBottom() && this._keepMovingDown) {\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    public rotate() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.rotate();\r\n        while (this._collidesRight()) {\r\n            this._piece.moveLeft();\r\n\r\n            if (this._collidesLeft()) {\r\n                this._piece.revert();\r\n                break;\r\n            }\r\n        }\r\n\r\n        this._drawPiece();\r\n    }\r\n\r\n    public moveDown() {\r\n        this._update();\r\n    }\r\n\r\n    private _clearFullLines() {\r\n        let linesCleared = 0;\r\n      \r\n        for (let row = this._gridSize.height - 1; row >= 0; row--) {\r\n          let isFull = true;\r\n          for (let col = 0; col < this._gridSize.width; col++) {\r\n            const pos = row * this._gridSize.width + col;\r\n            if (this.grid[pos].solid === false) {\r\n              isFull = false;\r\n              break;\r\n            }\r\n          }\r\n      \r\n          if (isFull) {\r\n            const emptyRow = Array.apply(null, Array(this._gridSize.width))\r\n              .map((idx) => new Tile());\r\n      \r\n            const topPortion = this.grid.slice(0, row * this._gridSize.width);\r\n      \r\n            this.grid.splice(0, ++row * this._gridSize.width, ...emptyRow.concat(topPortion));\r\n            this._lineCleared.next();\r\n            linesCleared++;\r\n          }\r\n        }\r\n      \r\n        if (linesCleared > 0) {\r\n          const speedIncrement = 15; \r\n          const newGameSpeed = this._gameSpeed - (linesCleared * speedIncrement);\r\n          this.updateGameSpeed(newGameSpeed);\r\n          const scoreIncrement = 20; \r\n          this.score += linesCleared * scoreIncrement;\r\n        }\r\n      }\r\n      \r\n    private _update() {\r\n        if (this._locked) {\r\n            return;\r\n        }\r\n        this._locked = true;\r\n        this._piece.revert();\r\n\r\n        this._clearPiece();\r\n        this._piece.store();\r\n\r\n        this._piece.moveDown();\r\n        if (this._collidesBottom()) {\r\n            this._keepMovingDown = false;\r\n            this._piece.revert();\r\n            this._markSolid();\r\n            this._drawPiece();\r\n\r\n            this._clearFullLines();\r\n\r\n            this._spawnNewPiece();\r\n            if (this._isGameOver()) {\r\n                this._onGameOver();\r\n                return;\r\n            }\r\n        }\r\n\r\n        this._drawPiece();\r\n        this._locked = false;\r\n    }\r\n\r\n    private _isGameOver() {\r\n        this._piece.store();\r\n        this._piece.moveDown();\r\n        if (this._collidesBottom()) {\r\n            return true;\r\n        }\r\n\r\n        this._piece.revert();\r\n        return false;\r\n    }\r\n\r\n    private _onGameOver() {\r\n        this.stop();\r\n        this._gameOver.next();\r\n    }\r\n\r\n    private _spawnNewPiece() {\r\n        this._piece = this._piecesFactory.getRandomPiecePiece(SPAWN_POSITION_X, SPAWN_POSITION_Y);\r\n    }\r\n\r\n    private _initializeEmptyBoard() {\r\n        const cellsCount = this._gridSize.width * this._gridSize.height;\r\n        this.grid = Array.apply(null, Array(cellsCount))\r\n            .map((idx) => new Tile());\r\n    }\r\n\r\n    private _clearPiece() {\r\n        this._piece.positionsOnGrid\r\n            .forEach((pos) => {\r\n                this.__changeCell(pos, {color: undefined});\r\n            });\r\n    }\r\n\r\n    private _drawPiece() {\r\n        this._piece.clearStore();\r\n        this._piece.positionsOnGrid\r\n            .forEach((pos) => {\r\n                this.__changeCell(pos, {color: this._piece.color});\r\n            });\r\n    }\r\n\r\n    private _markSolid() {\r\n        this._piece.positionsOnGrid.forEach((pos) => {\r\n            this.__changeCell(pos, {solid: true});\r\n        });\r\n    }\r\n\r\n    private __changeCell(pos: number, data = {}) {\r\n        this.grid[pos] = Object.assign({}, this.grid[pos], data);\r\n    }\r\n\r\n    private _collidesBottom() {\r\n        if (this._piece.bottomRow >= this._gridSize.height) {\r\n            return true;\r\n        }\r\n        return this.__collides();\r\n    }\r\n\r\n    private _collidesLeft() {\r\n        if (this._piece.leftCol < 0) {\r\n            return true;\r\n        }\r\n\r\n        return this.__collides();\r\n    }\r\n\r\n    private _collidesRight() {\r\n        if (this._piece.rightCol >= this._gridSize.width) {\r\n            return true;\r\n        }\r\n\r\n        return this.__collides();\r\n    }\r\n\r\n    private __collides() {\r\n        return this._piece.positionsOnGrid\r\n            .some((pos) => {\r\n                if (pos > 0 && this.grid[pos] && this.grid[pos].solid) {\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n    }\r\n    \r\n    public updateGameSpeed(speed: number): void {\r\n        this._gameSpeed = speed;\r\n        this.restartGameInterval();\r\n      }\r\n      \r\n      private restartGameInterval(): void {\r\n        clearInterval(this._gameInterval);\r\n        this._gameInterval = setInterval(() => {\r\n          if (this.moveDown) {\r\n            this.moveDown();\r\n          }\r\n        }, this._gameSpeed);\r\n      }\r\n      \r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}